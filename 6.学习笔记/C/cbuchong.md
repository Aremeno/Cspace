# C语言日常学习备忘录（记录个人的一些看法）

用于日常学习时的随记，便于日后进行整理。

## 数组学习

字符串数组应用到枚举里，就是为了方便把枚举里字符对应的值转换成字符串进行输出  
也就是说枚举的时候，里面的比如 RED, GREEN, BLUE 这些值，实际上是对应整数0,1,2  
而我最后的输出结果要求的还是那些颜色的名称  
因此我就可以引入一个字符串数组，最后通过这个数组的索引来输出想要的结果。

```c
typedef enum { RED, GREEN, BLUE } Color;
const char* ColorNames[] = { "RED", "GREEN", "BLUE" };
```

**存疑**
补：这里的char后面为什么要加一个星号呢?--这里要用到指针和字符串的知识。

### 数组的长度公式写法

数组的长度可以通过 sizeof 运算符来计算，公式如下：

```c
sizeof(array) / sizeof(array[0])
```

补充：sizeof运算符获取的是内存大小，就是所占的字节数。
解释:基于以上补充，很明显就能知道数组内元素的数据类型是一致的，因此总字节除以单元素字节数即可。

## 指针学习

### 指针的基础学习

指针的学习是必要的，动态内存的分配和释放都离不开指针  
每一个变量在内存中都有一个地址，每一个地址都定义了一个指针变量  
该指针变量可以通过&运算符来获取该地址。
所谓指针，也是需要定义类型的。

最后输出时，不带星号的话输出的是地址，带了星号的话输出的是地址对应的值。

说白了，指针就是个变量，这个变量存储的是另一个变量的存储地址（这个地址是十六进制表示的）。  
所以只有带了星号，才能访问到这个地址对应的值。

补―――C语言中，&运算符表示取地址，*运算符表示取值，%d表示输出整数，%p表示输出地址，%s表示输出字符串。%ld表示输出长整数。 **关注**

空指针是指不指向任何有效内存地址的指针。空指针的值为NULL，通常用于表示指针未被初始化或指向无效内存。

空指针既然空了，为什么还要定义它呢？
因为在某些情况下，我们需要一个指针变量来表示“没有指向任何有效对象”的状态。
例如，在函数中，如果一个指针参数被传递为NULL，函数可以通过检查这个指针是否为NULL来决定是否执行某些操作。
说白了，空指针可以用于判断执行流程。

### 指针的运算

指针的运算主要包括加法和减法。
指针的加与减不是数值的运算，而是内存地址的移动。
当对指针进行加法操作时，实际上是将指针移动到下一个元素的位置，移动的距离取决于指针所指向的数据类型的大小。
例如，如果一个指针指向一个整数类型的变量（假设整数类型占4个字节），那么对该指针进行加1操作，实际上是将指针的地址增加4个字节。

```c
int arr[] = {10, 20, 30};
int *p = arr; // 指向数组的第一个元素
p++; // 指向数组的第二个元素
```

### 指针的比较

指针的比较是看两个指针变量所指向的内存地址的关系。
可以用于遍历数组，判断指针是否到达数组的末尾。

```c
int arr[] = {10, 20, 30};
int *p = arr;
while (p < arr + sizeof(arr) / sizeof(arr[0])) {
    printf("%d\n", *p);
    p++;
}
```

### 指针数组

指针数组就是数组里的元素变成了指针变量。
指针数组用于处理多个字符串或者多个动态分配的内存块等情况。  
相较于普通数组，指针数组可以更灵活地管理内存和数据。

```c
const char* colors[] = { "RED", "GREEN", "BLUE" };//const是为了防止修改字符串内容
for (int i = 0; i < 3; i++) {
    printf("%s\n", colors[i]);//这里加了星号不行。
}
```

补――字符串指针数组有特殊的地方.*是解引用运算符，那么想要输出字符串就不用加*，直接用%s输出即可。
加了星号的话，输出的就是字符串的第一个字符的地址了。
并且%s要的是char*类型的指针，如果加了星号就变成char类型了。

补――const关键字定义的指针数组，数组内的元素不可修改。

### 指向指针的指针

指向指针的指针是一个指针变量，它存储的是另一个指针变量的地址。
指向指针的指针用于处理多级指针或者动态分配的二维数组等情况。

```c
int **ptr;
int a = 10;
int *p = &a;
ptr = &p; // ptr指向指针p的地址
printf("%d\n", **ptr); // 输出10
```

？――为什么要用两层指针。

### 指针与函数

#### 传递指针给函数

这个与传递变量给函数差不多，只不过传递的是指针变量。
***
这个解决了无法在调用函数的时候改变函数外变量值的问题。  
将值传递换为指针传递。

```c
void modifyValue(int *p) {
    *p = 20; // 修改指针所指向的值（该值在函数外部可见）
}
int main() {
    int a = 10;
    modifyValue(&a); // 传递变量a的地址
    printf("%d\n", a); // 输出20
    return 0;
}
```

#### 从函数返回指针

从函数返回指针时，需要确保返回的指针指向的是有效的内存地址。
不能返回指向局部变量的指针，因为局部变量在函数结束后会被销毁。
除非该变量是static类型的，或者是动态分配的内存。
?--下面的例子用到了动态分配内存（目前还没学到）

```c
int* createArray(int size) {
    int *arr = (int*)malloc(size * sizeof(int)); // 动态分配内存
    return arr; // 返回指向动态分配内存的指针
}
int main() {
    int *myArray = createArray(5); // 获取动态分配的数组
    // 使用myArray
    free(myArray); // 释放动态分配的内存
    return 0;
}
```

用途：动态分配内存，返回给调用函数使用。

#### 函数指针与回调函数

##### 函数指针

函数指针本质上是指针变量，但是它存储的是函数的地址。
函数指针用于实现回调函数、事件处理等功能。

具体的声明方法：

```c
void (*funcPtr)(int); // 声明一个函数指针，指向返回类型为void，参数为int的函数
```

补：函数名本身就是函数的地址，因此赋值的时候可以省略掉&符号。

函数指针说白了就是指针指向的变成了函数而已，实际上就是调用函数而已，所以最后得到的还是值而非地址。

##### 回调函数

首先我定义了一个函数，处理某个事件，然后我又定义了另一个函数，这个函数里调用了之前定义的那个函数。
而想要调用的话，需要把那个函数指针作为参数传递进去。

```c
void eventHandler(int event) {
    printf("处理事件: %d\n", event);
}

void registerEventHandler(void (*handler)(int)) {
    // 模拟事件发生
    handler(42);
}

int main() {
    registerEventHandler(eventHandler);
    return 0;
}
```

## 字符串

字符串实际就是一维字符数组，其以\0结尾。
所谓空字符(缩写为NUL)，就是用来标识字符串的结束位置的。
字符串就是以空字符结尾的，但是不必写入字符串里，编译器会自动添加。
也就是说\0可以不用写。但实际存在，因此字符串数组长度为其他数组长度+1。
但是最好还是显式地添加\0，以避免潜在的错误。

```c
char str[] = "Hello";
printf("%s\n", str); // 输出Hello
```

**C语言中，有很多字符串处理函数，这些函数定义在<string.h>头文件中。**
***
常用的字符串处理函数整理（部分）：

- strcpy(s1,s2):将字符串s2复制到s1中
- strcat(s1,s2):将字符串s2连接到s1的末尾
- strlen(s):获取字符串s的长度
- strcmp(s1, s2):s1和s2比较，相同则返回0，前者大则为正值，反之易知。
- strchr(s1, ch)：查找字符ch在字符串s1中第一次出现的位置，返回指针。
- strrchr(s1, ch)：查找字符ch在字符串s1中最后一次出现的位置，返回指针。
- strstr(s1, s2)：查找字符串s2在字符串s1中第一次出现的位置，返回指针。
  
补--字符串的输入输出用%s。

## 结构体

结构体是一种用户自定义数据类型，可以把不同类型的数据组合在一起。可以是基本数据类型，也可以是其他结构体或者指针。

### 结构体的定义

结构体的定义基本格式：

```c
struct StructName {
    dataType member1;
    dataType member2;
    // ...
} Name;
```

总共含有三个部分：结构体标签，成员变量，结构体变量。

各部分所代表的具体意义：

- 结构体标签：用于定义结构体类型的名称，可以在后续代码中使用该名称来声明结构体变量。
- 成员变量：结构体中包含的变量，可以是不同类型的数据。（成员变量可以通过结构体变量来访问）
- 结构体变量：根据结构体类型定义的变量，用于存储具体的数据。

**定义的时候至少包含有两个部分。**

**两个结构体互相嵌套时需注意。**

需要对其中一个结构体进行不完整声明：

```c
struct InnerStruct; // 不完整声明
struct OuterStruct {
    struct InnerStruct *inner; // 使用不完整类型
};
struct InnerStruct {
    struct OuterStruct *outer; // 使用不完整类型
};
```

### 结构体变量的初始化与访问

```c
struct Point {
    int x;
    int y;
};

int main() {
    struct Point p1 = {10, 20}; // 初始化结构体变量
    struct Point p2 = {.y = 30, .x = 40}; // 采用指定初始化方式

    printf("p1: (%d, %d)\n", p1.x, p1.y);
    printf("p2: (%d, %d)\n", p2.x, p2.y);

    return 0;
}
```

由此可见，访问结构体变量使用“.”运算符。
并且结构体变量可以有很多个，可以分别对内部成员进行访问和修改，但是不同的结构体变量之间是相互独立的。

### 结构体函数

结构体函数就是函数参数为结构体变量的函数。

```c
void printPoint(struct Point p) {
    printf("Point: (%d, %d)\n", p.x, p.y);
}

int main() {
    struct Point p1 = {10, 20};
    printPoint(p1);
    return 0;
}
```

### 结构体指针

结构体指针是指向结构体变量的指针变量。通过结构体指针可以访问和修改结构体的成员。

```c
struct Point {
    int x;
    int y;
};

int main() {
    struct Point p1 = {10, 20};
    struct Point *ptr = &p1; // 定义结构体指针并指向p1

    printf("Point: (%d, %d)\n", ptr->x, ptr->y); // 通过指针访问成员
    ptr->x = 30; // 通过指针修改成员
    printf("Point: (%d, %d)\n", ptr->x, ptr->y);

    return 0;
}
```

从上面这个例子就能看出来：
想要通过指针访问结构体成员，需要使用“->”运算符。

### 结构体大小的计算

可以使用sizeof运算符来计算，但是可能会受到内存对齐的影响。
如果想要排除这个的影响，可以使用offsetof宏来计算每个成员的偏移量，然后进行计算。(头文件为<stddef.h>)
（目前不作了解）

## 共用体

共用体是一种特殊的数据类型，允许在同一内存位置存储不同类型的数据。
共用体的定义格式与结构体类似，但是所有成员共享同一块内存空间。
但是共用体内存储的值只能有一个有效。

```c
union Data {
    int intValue;
    float floatValue;
    char strValue[32];
};
```

结构体和共用体都可以放在main函数外面定义。
共用体的大小取决于最大成员的大小。

## C位域

位域是一种特殊的结构体成员，允许在结构体中定义按位存储的变量。
位域的定义格式如下：

```c
struct BitField {
    unsigned int b1 : 1; // 1位
    unsigned int b2 : 2; // 2位
    unsigned int b3 : 3; // 3位
};
```

位域主要用于节省内存空间，适用于需要存储大量布尔值或小范围整数的场景。
可以存储开关状态等。

## typedef

typedef用于为已有的数据类型定义新的类型名称，简化代码书写，提高可读性。

```c
typedef unsigned long ulong;
typedef int (*funcPtr)(int, int);
```

说白了，typedef就是给类型起个别名，这个别名可以用来声明变量或者函数指针等。
比如：

```c
ulong a = 100;// 等同于 unsigned long a = 100;
funcPtr f = myFunction;// 等同于 int (*f)(int, int) = myFunction;
```

## 输入和输出

输入输出函数有以下几种：

注意：
标准化输入输出为stdin和stdout
stream为文件流。

这两者区别在于：标准输入输出是预定义的文件流，分别对应键盘和屏幕（被视为文件），而文件流是用户自定义的文件操作流。

- printf: 格式化输出到标准输出（通常是屏幕）
- scanf: 从标准输入（通常是键盘）格式化输入
- getchar: 从标准输入读取一个字符(注意它只会读取一个字符)
- putchar: 向标准输出写入一个字符
- gets: 从标准输入读取一行字符串(不安全，容易导致缓冲区溢出)
- puts: 向标准输出写入一行字符串(自动添加换行符。并且存在返回值，返回非负值表示成功，EOF表示失败（返回值可用于错误处理）)
- fgets()函数: 从指定的文件流中读取一行字符串，通常用于从标准输入读取字符串，较为安全。
- fputs()函数: 向指定的文件流写入一行字符串，通常用于向标准输出写入字符串。(不会自动添加换行符)

```c
char buffer[100];
fgets(buffer, sizeof(buffer), stdin);//fgets(一个字符数组（用于存储输入的字符串），读取的最大长度，输入流（固定为stdin))
```

补充说明：fgets函数会读取输入的换行符，并将其存储在缓冲区中。如果不希望包含换行符，可以在读取后手动移除它。

```c
char buffer[100];
fgets(buffer, sizeof(buffer), stdin);
buffer[strcspn(buffer, "\n")] = '\0'; // 手动移除换行符（意思就是把换行符替换为字符串结束符\0）
```

## 文件读写

- fopen: 打开文件，返回文件指针
- fclose: 关闭文件

具体的使用方式：

```c
FILE *fp = fopen("file.txt", "r"); // 打开文件
if (fp == NULL) {
    perror("Failed to open file");//perror用于输出错误信息
    return 1;//为什是么返回1呢？--表示程序异常终止，非0值通常表示错误。
}

// 读取文件内容
char buffer[100];
while (fgets(buffer, sizeof(buffer), fp) != NULL) //fp表示文件流,从文件中读取一行
//这个循环是读取文件所有内容，直到文件末尾
{
    printf("%s", buffer);
}

fclose(fp); // 关闭文件
```

除此之外还可能用到：

- fprintf: 格式化输出到文件
- fscanf: 从文件格式化输入（只会读取到空格或换行符为止）
- fread: 二进制方式从文件读取数据块
- fwrite: 二进制方式向文件写入数据块
- fgetc: 从文件读取一个字符
- fputc: 向文件写入一个字符
- fgets: 从文件读取一行字符串
- fputs: 向文件写入一行字符串
- feof: 检测文件结束标志
- ferror: 检测文件错误标志
- rewind: 将文件指针重新定位到文件开头
- ftell: 获取当前文件指针位置
- fseek: 设置文件指针位置
- setvbuf: 设置文件流的缓冲区模式
- fflush: 刷新文件流缓冲区
- remove: 删除文件
- rename: 重命名文件
- tmpfile: 创建临时文件
- tmpnam: 生成临时文件名
- perror: 输出错误信息
  
还有用于fopen的各种模式：

- "r": 以只读方式打开文件，文件必须存在。
- "w": 以写入方式打开文件，如果文件存在则清空内容，如果不存在则创建新文件。
- "a": 以追加方式打开文件，写入的数据会被添加到文件末尾，如果文件不存在则创建新文件。
- "r+": 以读写方式打开文件，文件必须存在。
- "w+": 以读写方式打开文件，如果文件存在则清空内容，如果不存在则创建新文件。
- "a+": 以读写追加方式打开文件，写入的数据会被添加到文件末尾，如果文件不存在则创建新文件。
- "rb": 以二进制只读方式打开文件，文件必须存在。
- "wb": 以二进制写入方式打开文件，如果文件存在则清空内容，如果不存在则创建新文件。
- "ab": 以二进制追加方式打开文件，写入的数据会被添加到文件末尾，如果文件不存在则创建新文件。

缓冲区的概念：  
缓冲区是内存中的一块临时存储区域，用于提高输入输出操作的效率。  
当进行文件读写操作时，数据通常不会直接从文件系统读取或写入，而是先存储在缓冲区中，然后再批量处理。

## 预处理器

所有预处理指令都以#开头，常见的预处理指令有：

- #define: 定义宏
- #include: 包含头文件
- #ifdef: 判断宏是否定义(如果已定义则编译下面的代码)
- #ifndef: 判断宏是否未定义（如果未定义则编译下面的代码）
- #endif: 结束条件编译(与#ifdef或#ifndef配合使用)
- #if: 条件编译(根据表达式的值决定是否编译下面的代码)
- #else: 条件编译的else部分
- #elif: 条件编译的else if部分
- #undef: 取消宏定义
- #error: 生成编译错误信息
- #pragma: 编译器指令(用于向编译器传递特定的指令)

**宏的命名建议使用大写字母和下划线。**

函数式宏定义：

```c
#define SQUARE(x) ((x) * (x))
```

需要注意的是每个参数和整个表达式都要加括号，以避免运算优先级问题。  
并且要避免使用多次计算参数的宏定义，以防止副作用。  

### 预定义宏

ANSI C定义了很多宏，有：

- __FILE__: 当前源文件的名称
- __LINE__: 当前源文件的行号
- __DATE__: 当前编译日期
- __TIME__: 当前编译时间
- __STDC__: 如果编译器符合ANSI C标准，则定义为1

### 条件编译

条件编译可以用于跨平台开发，以及调试代码。  
此内容目前不作过多了解。

### 预处理器运算符

- 宏延续运算符（\）: 用于将宏定义分成多行，增强可读性。
- 字符串常量化运算符（#）: 用于将宏参数转换为字符串。
- 标记粘贴运算符（##）: 用于将两个宏参数连接在一起，形成一个新的标识符。

## 头文件

头文件分类：

- 标准库头文件: 由C标准库提供，包含常用的函数和类型定义，如<stdio.h>、<stdlib.h>等。
- 自定义头文件: 由用户创建，包含自定义的函数和类型定义

建议把所有的常量、宏定义、结构体定义、函数声明、系统全局变量等放在头文件中。

### 头文件保护

头文件保护是为了防止头文件被多次包含导致的重定义错误。常用的头文件保护方法有：

- 使用宏定义

```c
#ifndef MY_HEADER_H
#define MY_HEADER_H

// 头文件内容

#endif
```

- 使用#pragma once

```c
#pragma once

// 头文件内容
```

- #pragma once 是一种非标准但广泛支持的头文件保护方式，使用起来更简洁。

### 标准头文件

常见的标准头文件有：

- <stdio.h>: 标准输入输出库
- <stdlib.h>: 标准库，包含动态内存管理、随机数生成等函数
- <string.h>: 字符串处理库
- <math.h>: 数学库，包含常用数学函数
- <time.h>: 时间日期库
- <ctype.h>: 字符处理库
- <stddef.h>: 定义了常用的类型和宏，如size_t、ptrdiff_t、offsetof等
- <limits.h>: 定义了各种数据类型的限制值
- <errno.h>: 定义了错误码和相关函数
- <assert.h>: 提供断言功能，用于调试程序
- <stdbool.h>: 定义了布尔类型和true、false常量
- <fcntl.h>: 文件控制选项
- <unistd.h>: 提供对POSIX操作系统API的访问
  
## 强制类型转换

强制类型转换用于将一种数据类型转换为另一种数据类型，语法格式如下：

```c
(type) expression
```

例如：

```c
int a = 10;
float b = (float)a; // 将int类型转换为float类型
```

强制类型转换可以用于避免类型不匹配的错误，或者在需要特定类型时进行转换。  
需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因此在使用时应谨慎。  
例如，将浮点数转换为整数时，小数部分会被截断：

```c
float c = 3.14;
int d = (int)c; // 将float类型转换为int类型
```

## 错误处理

在发生错误时，大多数返回值为1或NULL，同时会设置全局变量errno以指示错误类型。  
一般会在程序初始化时把errno设置为0（表示没有错误）。

可以使用perror函数输出错误信息，或者使用strerror函数获取错误描述字符串。

```c
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main() {
    FILE *fp = fopen("nonexistent.txt", "r");
    if (fp == NULL) {
        perror("Error opening file");
        printf("Error description: %s\n", strerror(errno));
        return 1;
    }
    fclose(fp);
    return 0;
}
```

- perror函数会显示传给它的字符串参数，后面跟着一个冒号和一个空格，然后是根据当前errno值输出的错误描述信息。
- strerror函数根据传入的errno值返回对应的错误描述字符串。

## 递归

递归就是函数调用自身。  
但是递归函数要有一个终止条件，防止无限递归导致栈溢出。

```c
#include <stdio.h>

void recursiveFunction(int n) {
    if (n == 0) {
        printf("Reached the base case\n");
        return;
    }
    printf("Recursing with n = %d\n", n);
    recursiveFunction(n - 1);
}

int main() {
    recursiveFunction(5);
    return 0;
}
```

## 内存管理

动态内存分配函数：

- malloc: 分配指定字节数的内存，返回指向分配内存的指针
- calloc: 分配指定数量的内存块，并初始化为0，返回指向分配内存的指针
- realloc: 重新分配内存块的大小，返回指向新分配内存的指针
- free: 释放之前分配的内存块

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>

int main() {
    int *arr = (int *)malloc(5 * sizeof(int));//动态地分配5个大小为int的内存空间
    if (arr == NULL) {
        perror("Error allocating memory");
        return 1;//内存分配失败，返回1表示错误
    }
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 2;
    }
    for (int i = 0; i < 5; i++) {
        printf("%d\n", arr[i]);
    }
    free(arr);
    return 0;
}
```

动态内存分配需要注意内存泄漏的问题，分配的内存使用完毕后必须及时释放。

realloc函数的使用语法：

```c
ptr = realloc(ptr, new_size);
```

## 可变参数

暂停学习。
