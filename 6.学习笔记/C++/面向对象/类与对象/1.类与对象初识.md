# 类与对象初识

## 从C的结构体到C++的类

### C语言的结构体

在C语言中，我们使用结构体（`struct`）来定义一种复合数据类型，它可以包含多个不同类型的成员变量。例如：

```c
struct Student {
    char name[20];
    int age;
    float score;
} ;

struct Student s1;
strcpy(s1.name, "Alice");
s1.age = 20;
s1.score = 95.5;
```

然而，C语言的结构体只能包含数据成员，不能包含函数成员，这限制了我们对数据和行为的封装能力。C++引入了类（`class`）的概念，允许我们将数据和操作数据的函数封装在一起，从而实现更强大的面向对象编程。

### C++的类

将上述结构体转换为C++的类，我们可以这样定义：

```cpp
class Student {
public:
    string name;
    int age;
    float score;
    void display() {
        cout << "Name: " << name << ", Age: " << age << ", Score: " << score << endl;
    }
    void setInfo(string n,int a,float s) {
        name = n;
        age = a;
        score = s;
    }
};

Student s1;
s1.setInfo("Alice", 20, 95.5);
s1.display();
```

## 类的三大核心特性

### 封装（Encapsulation）

它将数据和操作数据的函数放在一起，隐藏了内部实现细节，只暴露必要的接口给外部使用。

例子：

```cpp
class BankAccount {
private:
    string accountNumber;
    double balance;
public:
    void deposit(double amount) {
        if(amount > 0) {
            balance += amount;
        }
    }
    bool withdraw(double amount) {
        if(amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }
    double getBalance() {
        return balance;
    }
};
```

封装的好处：

- 数据安全（balance不能直接修改）
- 使用简单（只需要调用deposit和withdraw方法）
- 修改灵活（内部实现可以改，不影响使用者）

### 继承（Inheritance）

一个类（派生类）可以继承另一个类（基类）的属性和方法，并可以扩展或重写它们。

例子：

```cpp
class Animal {
protected:
    string name;
    int age;

public:
    Animal(string n, int a) : name(n), age(a) {}

    void eat() {
        cout << name << " is eating." << endl;
    }

    void sleep() {
        cout << name << " is sleeping." << endl;
    }

    virtual void makeSound() {  // 虚函数
        cout << name << " makes a sound." << endl;
    }
};

// 派生类 - 公有继承
class Dog :public Animal {
private:
    string breed;

public:
    Dog(string n, int a, string b) :Animal(n, a), breed(b) {}

    void bark() {
        cout << name << " barks." << endl;
    }

    void makeSound() override {  // 重写基类的虚函数
        cout << name << " barks loudly." << endl;
    }
    
    void display() {
        cout << name << "是一只" << breed << "，年龄为" << age << "岁。" << endl;
    }
};

// 另一个派生类 - 公有继承
class Cat : public Animal {
private:
    string color;


public:
    Cat(string n, int a, string c) :Animal(n, a), color(c) {}

    void makeSound() override {  // 重写基类的虚函数
        cout << name << " meows softly." << endl;
    }
    void climbTree() {
        cout << name << " climbs a tree." << endl;
    }
};

int main() {
    Dog dog("旺财",2, "金毛");
    Cat cat("咪咪",1,"白色");

    dog.eat();          // 继承自Animal类
    dog.bark();        // Dog类特有的方法
    dog.makeSound();   // 重写后的方法
    dog.sleep();       // 继承自Animal类
    dog.display();
    cat.eat();         // 继承自Animal类
    cat.climbTree();   // Cat类特有的方法
    cat.makeSound();  // 重写后的方法
    cat.sleep();      // 继承自Animal类
    return 0;
}
```

#### 继承的类型

- 公有继承（`public`）：基类的公有成员和保护成员在派生类中保持其访问权限。
- 保护继承（`protected`）：基类的公有成员和保护成员在派生类中变为保护成员。
- 私有继承（`private`）：基类的公有成员和保护成员在派生类中变为私有成员。

但是基类的私有成员在派生类中不可访问。

### 多态（Polymorphism）

同一操作作用于不同的对象，可以有不同的解释和不同的执行结果。多态通常通过虚函数实现。

例子：

```cpp
class Shape {
protected:
    string name;

public:
    Shape(string n) : name(n) {}

    // 虚函数(实现多态的关键)
    virtual double area() const {
        cout << "计算形状面积" << endl;
        return 0;
    }

    virtual void draw() const {
        cout << "绘制形状" << endl;
    }

    virtual ~Shape() {
        cout << "销毁Shape对象" << endl;
    }
};

class Circle : public Shape {
private:
    double radius;

public:
    Circle(string n, double r) : Shape(n), radius(r) {}

    double area() const override {
        return 3.14159 * radius * radius;
    }

    void draw() const override {
        cout << "绘制圆形" << name << "，半径为" << radius << endl;  
    }

};

class Rectangle : public Shape {
private:
    double width,height;

public:
    Rectangle(string n,double w,double h) :Shape(n),width(w),height(h) {}

    double area() const override {
        return width * height;
    }

    void draw() const override {
        cout << "绘制矩形" << name << "，宽为" << width << "，高为" << height << endl;

    }
};

class Triangle : public Shape {
private:
    double base,height;
public:
    Triangle(string n,double b,double h) :Shape(n),base(b),height(h) {}

    double area() const override {
        return 0.5 * base * height;
    }

    void draw() const override {
        cout << "绘制三角形" << name << "，底为" << base << "，高为" << height << endl;

    }
};

int main() {
    // 多态的魅力（基类指针指向派生类对象）
    Shape* shapes[3];
    shapes[0] = new Circle("Circle1", 5.0);
    shapes[1] = new Rectangle("Rectangle1", 4.0, 6.0);
    shapes[2] = new Triangle("Triangle1", 3.0, 4.0);
    for (int i = 0; i < 3; ++i) {
        shapes[i]->draw();
        cout << "Area: " << shapes[i]->area() << endl;
        cout << endl;
    }

    // 释放内存
    for (int i = 0; i < 3; ++i) {
        delete shapes[i];
    }
    return 0;
}
```

## 构造函数与析构函数

### 构造函数（Constructor）

构造函数是一种特殊的成员函数，用于在创建对象时初始化对象的成员变量。它的名称与类名相同，没有返回类型。

例子：

```cpp
class Person {
private:
    string name;
    int age;


// 1. 默认构造函数
Person() {
    name = "Unknown";
    age = 0;
    cout << "默认构造函数被调用" << endl;
}

// 2. 带参数的构造函数
Person(string n,int a) {
    name = n;
    age = a;
    cout << "带参数的构造函数被调用" << endl;
}

// 3. 初始化列表（推荐使用）

Person(string n, int a) : name(n), age(a) {}
};
```

### 析构函数（Destructor）

析构函数也是一种特殊的成员函数，用于在对象销毁时执行清理操作。它的名称与类名相同，前面加上波浪号（`~`），没有返回类型和参数。

例子：

```cpp
class DataProcessor {
public:
    int* data;
    int size;

public:
    DataProcessor(int s) : size(s) {
        data = new int[size];
        cout << "构造函数：分配内存" << endl;
    }

    ~DataProcessor() {
        delete[] data;
        cout << "析构函数：释放内存" << endl;
    }
};
```

